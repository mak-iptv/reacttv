{"ast":null,"code":"\"use client\";\n\nimport { jsx as ee } from \"react/jsx-runtime\";\nimport { useState as M, useLayoutEffect as re, useEffect as J, useMemo as A, useRef as K, useCallback as D, memo as le, useImperativeHandle as ce, createElement as X } from \"react\";\nfunction xe(e) {\n  let t = e;\n  for (; t;) {\n    if (t.dir) return t.dir === \"rtl\";\n    t = t.parentElement;\n  }\n  return !1;\n}\nfunction ve(e, t) {\n  const [s, r] = M(t === \"rtl\");\n  return re(() => {\n    e && (t || r(xe(e)));\n  }, [t, e]), s;\n}\nconst q = typeof window < \"u\" ? re : J;\nfunction ie(e) {\n  if (e !== void 0) switch (typeof e) {\n    case \"number\":\n      return e;\n    case \"string\":\n      {\n        if (e.endsWith(\"px\")) return parseFloat(e);\n        break;\n      }\n  }\n}\nfunction be({\n  box: e,\n  defaultHeight: t,\n  defaultWidth: s,\n  disabled: r,\n  element: n,\n  mode: o,\n  style: i\n}) {\n  const {\n      styleHeight: f,\n      styleWidth: l\n    } = A(() => ({\n      styleHeight: ie(i?.height),\n      styleWidth: ie(i?.width)\n    }), [i?.height, i?.width]),\n    [c, d] = M({\n      height: t,\n      width: s\n    }),\n    a = r || o === \"only-height\" && f !== void 0 || o === \"only-width\" && l !== void 0 || f !== void 0 && l !== void 0;\n  return q(() => {\n    if (n === null || a) return;\n    const h = new ResizeObserver(p => {\n      for (const I of p) {\n        const {\n          contentRect: u,\n          target: w\n        } = I;\n        n === w && d(m => m.height === u.height && m.width === u.width ? m : {\n          height: u.height,\n          width: u.width\n        });\n      }\n    });\n    return h.observe(n, {\n      box: e\n    }), () => {\n      h?.unobserve(n);\n    };\n  }, [e, a, n, f, l]), A(() => ({\n    height: f ?? c.height,\n    width: l ?? c.width\n  }), [c, f, l]);\n}\nfunction ae(e) {\n  const t = K(() => {\n    throw new Error(\"Cannot call during render.\");\n  });\n  return q(() => {\n    t.current = e;\n  }, [e]), D(s => t.current?.(s), [t]);\n}\nlet U = null;\nfunction Ie(e = !1) {\n  if (U === null || e) {\n    const t = document.createElement(\"div\"),\n      s = t.style;\n    s.width = \"50px\", s.height = \"50px\", s.overflow = \"scroll\", s.direction = \"rtl\";\n    const r = document.createElement(\"div\"),\n      n = r.style;\n    return n.width = \"100px\", n.height = \"100px\", t.appendChild(r), document.body.appendChild(t), t.scrollLeft > 0 ? U = \"positive-descending\" : (t.scrollLeft = 1, t.scrollLeft === 0 ? U = \"negative\" : U = \"positive-ascending\"), document.body.removeChild(t), U;\n  }\n  return U;\n}\nfunction Z({\n  containerElement: e,\n  direction: t,\n  isRtl: s,\n  scrollOffset: r\n}) {\n  if (t === \"horizontal\" && s) switch (Ie()) {\n    case \"negative\":\n      return -r;\n    case \"positive-descending\":\n      {\n        if (e) {\n          const {\n            clientWidth: n,\n            scrollLeft: o,\n            scrollWidth: i\n          } = e;\n          return i - n - o;\n        }\n        break;\n      }\n  }\n  return r;\n}\nfunction L(e, t = \"Assertion error\") {\n  if (!e) throw console.error(t), Error(t);\n}\nfunction Y(e, t) {\n  if (e === t) return !0;\n  if (!!e != !!t || (L(e !== void 0), L(t !== void 0), Object.keys(e).length !== Object.keys(t).length)) return !1;\n  for (const s in e) if (!Object.is(t[s], e[s])) return !1;\n  return !0;\n}\nfunction fe({\n  cachedBounds: e,\n  itemCount: t,\n  itemSize: s\n}) {\n  if (t === 0) return 0;\n  if (typeof s == \"number\") return t * s;\n  {\n    const r = e.get(e.size === 0 ? 0 : e.size - 1);\n    L(r !== void 0, \"Unexpected bounds cache miss\");\n    const n = (r.scrollOffset + r.size) / e.size;\n    return t * n;\n  }\n}\nfunction we({\n  align: e,\n  cachedBounds: t,\n  index: s,\n  itemCount: r,\n  itemSize: n,\n  containerScrollOffset: o,\n  containerSize: i\n}) {\n  if (s < 0 || s >= r) throw RangeError(`Invalid index specified: ${s}`, {\n    cause: `Index ${s} is not within the range of 0 - ${r - 1}`\n  });\n  const f = fe({\n      cachedBounds: t,\n      itemCount: r,\n      itemSize: n\n    }),\n    l = t.get(s),\n    c = Math.max(0, Math.min(f - i, l.scrollOffset)),\n    d = Math.max(0, l.scrollOffset - i + l.size);\n  switch (e === \"smart\" && (o >= d && o <= c ? e = \"auto\" : e = \"center\"), e) {\n    case \"start\":\n      return c;\n    case \"end\":\n      return d;\n    case \"center\":\n      return l.scrollOffset <= i / 2 ? 0 : l.scrollOffset + l.size / 2 >= f - i / 2 ? f - i : l.scrollOffset + l.size / 2 - i / 2;\n    case \"auto\":\n    default:\n      return o >= d && o <= c ? o : o < d ? d : c;\n  }\n}\nfunction P({\n  cachedBounds: e,\n  containerScrollOffset: t,\n  containerSize: s,\n  itemCount: r,\n  overscanCount: n\n}) {\n  const o = r - 1;\n  let i = 0,\n    f = -1,\n    l = 0,\n    c = -1,\n    d = 0;\n  for (; d < o;) {\n    const a = e.get(d);\n    if (a.scrollOffset + a.size > t) break;\n    d++;\n  }\n  for (i = d, l = Math.max(0, i - n); d < o;) {\n    const a = e.get(d);\n    if (a.scrollOffset + a.size >= t + s) break;\n    d++;\n  }\n  return f = Math.min(o, d), c = Math.min(r - 1, f + n), i < 0 && (i = 0, f = -1, l = 0, c = -1), {\n    startIndexVisible: i,\n    stopIndexVisible: f,\n    startIndexOverscan: l,\n    stopIndexOverscan: c\n  };\n}\nfunction me({\n  itemCount: e,\n  itemProps: t,\n  itemSize: s\n}) {\n  const r = /* @__PURE__ */new Map();\n  return {\n    get(n) {\n      for (L(n < e, `Invalid index ${n}`); r.size - 1 < n;) {\n        const i = r.size;\n        let f;\n        switch (typeof s) {\n          case \"function\":\n            {\n              f = s(i, t);\n              break;\n            }\n          case \"number\":\n            {\n              f = s;\n              break;\n            }\n        }\n        if (i === 0) r.set(i, {\n          size: f,\n          scrollOffset: 0\n        });else {\n          const l = r.get(i - 1);\n          L(l !== void 0, `Unexpected bounds cache miss for index ${n}`), r.set(i, {\n            scrollOffset: l.scrollOffset + l.size,\n            size: f\n          });\n        }\n      }\n      const o = r.get(n);\n      return L(o !== void 0, `Unexpected bounds cache miss for index ${n}`), o;\n    },\n    set(n, o) {\n      r.set(n, o);\n    },\n    get size() {\n      return r.size;\n    }\n  };\n}\nfunction Oe({\n  itemCount: e,\n  itemProps: t,\n  itemSize: s\n}) {\n  return A(() => me({\n    itemCount: e,\n    itemProps: t,\n    itemSize: s\n  }), [e, t, s]);\n}\nfunction ye({\n  containerSize: e,\n  itemSize: t\n}) {\n  let s;\n  switch (typeof t) {\n    case \"string\":\n      {\n        L(t.endsWith(\"%\"), `Invalid item size: \"${t}\"; string values must be percentages (e.g. \"100%\")`), L(e !== void 0, \"Container size must be defined if a percentage item size is specified\"), s = e * parseInt(t) / 100;\n        break;\n      }\n    default:\n      {\n        s = t;\n        break;\n      }\n  }\n  return s;\n}\nfunction te({\n  containerElement: e,\n  containerStyle: t,\n  defaultContainerSize: s = 0,\n  direction: r,\n  isRtl: n = !1,\n  itemCount: o,\n  itemProps: i,\n  itemSize: f,\n  onResize: l,\n  overscanCount: c\n}) {\n  const {\n      height: d = s,\n      width: a = s\n    } = be({\n      defaultHeight: r === \"vertical\" ? s : void 0,\n      defaultWidth: r === \"horizontal\" ? s : void 0,\n      element: e,\n      mode: r === \"vertical\" ? \"only-height\" : \"only-width\",\n      style: t\n    }),\n    h = K({\n      height: 0,\n      width: 0\n    }),\n    p = r === \"vertical\" ? d : a,\n    I = ye({\n      containerSize: p,\n      itemSize: f\n    });\n  re(() => {\n    if (typeof l == \"function\") {\n      const g = h.current;\n      (g.height !== d || g.width !== a) && (l({\n        height: d,\n        width: a\n      }, {\n        ...g\n      }), g.height = d, g.width = a);\n    }\n  }, [d, l, a]);\n  const u = Oe({\n      itemCount: o,\n      itemProps: i,\n      itemSize: I\n    }),\n    w = D(g => u.get(g), [u]),\n    [m, O] = M(() => P({\n      cachedBounds: u,\n      // TODO Potentially support a defaultScrollOffset prop?\n      containerScrollOffset: 0,\n      containerSize: p,\n      itemCount: o,\n      overscanCount: c\n    })),\n    {\n      startIndexVisible: G,\n      startIndexOverscan: x,\n      stopIndexVisible: F,\n      stopIndexOverscan: V\n    } = {\n      startIndexVisible: Math.min(o - 1, m.startIndexVisible),\n      startIndexOverscan: Math.min(o - 1, m.startIndexOverscan),\n      stopIndexVisible: Math.min(o - 1, m.stopIndexVisible),\n      stopIndexOverscan: Math.min(o - 1, m.stopIndexOverscan)\n    },\n    z = D(() => fe({\n      cachedBounds: u,\n      itemCount: o,\n      itemSize: I\n    }), [u, o, I]),\n    $ = D(g => {\n      const S = Z({\n        containerElement: e,\n        direction: r,\n        isRtl: n,\n        scrollOffset: g\n      });\n      return P({\n        cachedBounds: u,\n        containerScrollOffset: S,\n        containerSize: p,\n        itemCount: o,\n        overscanCount: c\n      });\n    }, [u, e, p, r, n, o, c]);\n  q(() => {\n    const g = (r === \"vertical\" ? e?.scrollTop : e?.scrollLeft) ?? 0;\n    O($(g));\n  }, [e, r, $]), q(() => {\n    if (!e) return;\n    const g = () => {\n      O(S => {\n        const {\n            scrollLeft: E,\n            scrollTop: b\n          } = e,\n          v = Z({\n            containerElement: e,\n            direction: r,\n            isRtl: n,\n            scrollOffset: r === \"vertical\" ? b : E\n          }),\n          R = P({\n            cachedBounds: u,\n            containerScrollOffset: v,\n            containerSize: p,\n            itemCount: o,\n            overscanCount: c\n          });\n        return Y(R, S) ? S : R;\n      });\n    };\n    return e.addEventListener(\"scroll\", g), () => {\n      e.removeEventListener(\"scroll\", g);\n    };\n  }, [u, e, p, r, o, c]);\n  const y = ae(({\n    align: g = \"auto\",\n    containerScrollOffset: S,\n    index: E\n  }) => {\n    let b = we({\n      align: g,\n      cachedBounds: u,\n      containerScrollOffset: S,\n      containerSize: p,\n      index: E,\n      itemCount: o,\n      itemSize: I\n    });\n    if (e) {\n      if (b = Z({\n        containerElement: e,\n        direction: r,\n        isRtl: n,\n        scrollOffset: b\n      }), typeof e.scrollTo != \"function\") {\n        const v = $(b);\n        Y(m, v) || O(v);\n      }\n      return b;\n    }\n  });\n  return {\n    getCellBounds: w,\n    getEstimatedSize: z,\n    scrollToIndex: y,\n    startIndexOverscan: x,\n    startIndexVisible: G,\n    stopIndexOverscan: V,\n    stopIndexVisible: F\n  };\n}\nfunction de(e) {\n  return A(() => e, Object.values(e));\n}\nfunction ue(e, t) {\n  const {\n      ariaAttributes: s,\n      style: r,\n      ...n\n    } = e,\n    {\n      ariaAttributes: o,\n      style: i,\n      ...f\n    } = t;\n  return Y(s, o) && Y(r, i) && Y(n, f);\n}\nfunction Ee({\n  cellComponent: e,\n  cellProps: t,\n  children: s,\n  className: r,\n  columnCount: n,\n  columnWidth: o,\n  defaultHeight: i = 0,\n  defaultWidth: f = 0,\n  dir: l,\n  gridRef: c,\n  onCellsRendered: d,\n  onResize: a,\n  overscanCount: h = 3,\n  rowCount: p,\n  rowHeight: I,\n  style: u,\n  tagName: w = \"div\",\n  ...m\n}) {\n  const O = de(t),\n    G = A(() => le(e, ue), [e]),\n    [x, F] = M(null),\n    V = ve(x, l),\n    {\n      getCellBounds: z,\n      getEstimatedSize: $,\n      startIndexOverscan: y,\n      startIndexVisible: g,\n      scrollToIndex: S,\n      stopIndexOverscan: E,\n      stopIndexVisible: b\n    } = te({\n      containerElement: x,\n      containerStyle: u,\n      defaultContainerSize: f,\n      direction: \"horizontal\",\n      isRtl: V,\n      itemCount: n,\n      itemProps: O,\n      itemSize: o,\n      onResize: a,\n      overscanCount: h\n    }),\n    {\n      getCellBounds: v,\n      getEstimatedSize: R,\n      startIndexOverscan: k,\n      startIndexVisible: ne,\n      scrollToIndex: Q,\n      stopIndexOverscan: _,\n      stopIndexVisible: oe\n    } = te({\n      containerElement: x,\n      containerStyle: u,\n      defaultContainerSize: i,\n      direction: \"vertical\",\n      itemCount: p,\n      itemProps: O,\n      itemSize: I,\n      onResize: a,\n      overscanCount: h\n    });\n  ce(c, () => ({\n    get element() {\n      return x;\n    },\n    scrollToCell({\n      behavior: H = \"auto\",\n      columnAlign: T = \"auto\",\n      columnIndex: W,\n      rowAlign: B = \"auto\",\n      rowIndex: j\n    }) {\n      const N = S({\n          align: T,\n          containerScrollOffset: x?.scrollLeft ?? 0,\n          index: W\n        }),\n        ge = Q({\n          align: B,\n          containerScrollOffset: x?.scrollTop ?? 0,\n          index: j\n        });\n      typeof x?.scrollTo == \"function\" && x.scrollTo({\n        behavior: H,\n        left: N,\n        top: ge\n      });\n    },\n    scrollToColumn({\n      align: H = \"auto\",\n      behavior: T = \"auto\",\n      index: W\n    }) {\n      const B = S({\n        align: H,\n        containerScrollOffset: x?.scrollLeft ?? 0,\n        index: W\n      });\n      typeof x?.scrollTo == \"function\" && x.scrollTo({\n        behavior: T,\n        left: B\n      });\n    },\n    scrollToRow({\n      align: H = \"auto\",\n      behavior: T = \"auto\",\n      index: W\n    }) {\n      const B = Q({\n        align: H,\n        containerScrollOffset: x?.scrollTop ?? 0,\n        index: W\n      });\n      typeof x?.scrollTo == \"function\" && x.scrollTo({\n        behavior: T,\n        top: B\n      });\n    }\n  }), [x, S, Q]), J(() => {\n    y >= 0 && E >= 0 && k >= 0 && _ >= 0 && d && d({\n      columnStartIndex: g,\n      columnStopIndex: b,\n      rowStartIndex: ne,\n      rowStopIndex: oe\n    }, {\n      columnStartIndex: y,\n      columnStopIndex: E,\n      rowStartIndex: k,\n      rowStopIndex: _\n    });\n  }, [d, y, g, E, b, k, ne, _, oe]);\n  const he = A(() => {\n      const H = [];\n      if (n > 0 && p > 0) for (let T = k; T <= _; T++) {\n        const W = v(T),\n          B = [];\n        for (let j = y; j <= E; j++) {\n          const N = z(j);\n          B.push(/* @__PURE__ */X(G, {\n            ...O,\n            ariaAttributes: {\n              \"aria-colindex\": j + 1,\n              role: \"gridcell\"\n            },\n            columnIndex: j,\n            key: j,\n            rowIndex: T,\n            style: {\n              position: \"absolute\",\n              left: V ? void 0 : 0,\n              right: V ? 0 : void 0,\n              transform: `translate(${V ? -N.scrollOffset : N.scrollOffset}px, ${W.scrollOffset}px)`,\n              height: W.size,\n              width: N.size\n            }\n          }));\n        }\n        H.push(/* @__PURE__ */ee(\"div\", {\n          role: \"row\",\n          \"aria-rowindex\": T + 1,\n          children: B\n        }, T));\n      }\n      return H;\n    }, [G, O, n, y, E, z, v, V, p, k, _]),\n    pe = /* @__PURE__ */ee(\"div\", {\n      \"aria-hidden\": !0,\n      style: {\n        height: R(),\n        width: $(),\n        zIndex: -1\n      }\n    });\n  return X(w, {\n    \"aria-colcount\": n,\n    \"aria-rowcount\": p,\n    role: \"grid\",\n    ...m,\n    className: r,\n    dir: l,\n    ref: F,\n    style: {\n      position: \"relative\",\n      maxHeight: \"100%\",\n      maxWidth: \"100%\",\n      flexGrow: 1,\n      overflow: \"auto\",\n      ...u\n    }\n  }, he, s, pe);\n}\nconst Re = M,\n  Ve = K;\nfunction ze(e) {\n  return e != null && typeof e == \"object\" && \"getAverageRowHeight\" in e && typeof e.getAverageRowHeight == \"function\";\n}\nconst se = \"data-react-window-index\";\nfunction Ae({\n  children: e,\n  className: t,\n  defaultHeight: s = 0,\n  listRef: r,\n  onResize: n,\n  onRowsRendered: o,\n  overscanCount: i = 3,\n  rowComponent: f,\n  rowCount: l,\n  rowHeight: c,\n  rowProps: d,\n  tagName: a = \"div\",\n  style: h,\n  ...p\n}) {\n  const I = de(d),\n    u = A(() => le(f, ue), [f]),\n    [w, m] = M(null),\n    O = ze(c),\n    G = A(() => O ? b => c.getRowHeight(b) ?? c.getAverageRowHeight() : c, [O, c]),\n    {\n      getCellBounds: x,\n      getEstimatedSize: F,\n      scrollToIndex: V,\n      startIndexOverscan: z,\n      startIndexVisible: $,\n      stopIndexOverscan: y,\n      stopIndexVisible: g\n    } = te({\n      containerElement: w,\n      containerStyle: h,\n      defaultContainerSize: s,\n      direction: \"vertical\",\n      itemCount: l,\n      itemProps: I,\n      itemSize: G,\n      onResize: n,\n      overscanCount: i\n    });\n  ce(r, () => ({\n    get element() {\n      return w;\n    },\n    scrollToRow({\n      align: b = \"auto\",\n      behavior: v = \"auto\",\n      index: R\n    }) {\n      const k = V({\n        align: b,\n        containerScrollOffset: w?.scrollTop ?? 0,\n        index: R\n      });\n      typeof w?.scrollTo == \"function\" && w.scrollTo({\n        behavior: v,\n        top: k\n      });\n    }\n  }), [w, V]), q(() => {\n    if (!w) return;\n    const b = Array.from(w.children).filter((v, R) => {\n      if (v.hasAttribute(\"aria-hidden\")) return !1;\n      const k = `${z + R}`;\n      return v.setAttribute(se, k), !0;\n    });\n    if (O) return c.observeRowElements(b);\n  }, [w, O, c, z, y]), J(() => {\n    z >= 0 && y >= 0 && o && o({\n      startIndex: $,\n      stopIndex: g\n    }, {\n      startIndex: z,\n      stopIndex: y\n    });\n  }, [o, z, $, y, g]);\n  const S = A(() => {\n      const b = [];\n      if (l > 0) for (let v = z; v <= y; v++) {\n        const R = x(v);\n        b.push(/* @__PURE__ */X(u, {\n          ...I,\n          ariaAttributes: {\n            \"aria-posinset\": v + 1,\n            \"aria-setsize\": l,\n            role: \"listitem\"\n          },\n          key: v,\n          index: v,\n          style: {\n            position: \"absolute\",\n            left: 0,\n            transform: `translateY(${R.scrollOffset}px)`,\n            // In case of dynamic row heights, don't specify a height style\n            // otherwise a default/estimated height would mask the actual height\n            height: O ? void 0 : R.size,\n            width: \"100%\"\n          }\n        }));\n      }\n      return b;\n    }, [u, x, O, l, I, z, y]),\n    E = /* @__PURE__ */ee(\"div\", {\n      \"aria-hidden\": !0,\n      style: {\n        height: F(),\n        width: \"100%\",\n        zIndex: -1\n      }\n    });\n  return X(a, {\n    role: \"list\",\n    ...p,\n    className: t,\n    ref: m,\n    style: {\n      position: \"relative\",\n      maxHeight: \"100%\",\n      flexGrow: 1,\n      overflowY: \"auto\",\n      ...h\n    }\n  }, S, e, E);\n}\nfunction ke({\n  defaultRowHeight: e,\n  key: t\n}) {\n  const [s, r] = M({\n    key: t,\n    map: /* @__PURE__ */new Map()\n  });\n  s.key !== t && r({\n    key: t,\n    map: /* @__PURE__ */new Map()\n  });\n  const {\n      map: n\n    } = s,\n    o = D(() => {\n      let a = 0;\n      return n.forEach(h => {\n        a += h;\n      }), a === 0 ? e : a / n.size;\n    }, [e, n]),\n    i = D(a => {\n      const h = n.get(a);\n      return h !== void 0 ? h : (n.set(a, e), e);\n    }, [e, n]),\n    f = D((a, h) => {\n      r(p => {\n        if (p.map.get(a) === h) return p;\n        const I = new Map(p.map);\n        return I.set(a, h), {\n          ...p,\n          map: I\n        };\n      });\n    }, []),\n    l = ae(a => {\n      a.length !== 0 && a.forEach(h => {\n        const {\n            borderBoxSize: p,\n            target: I\n          } = h,\n          u = I.getAttribute(se);\n        L(u !== null, `Invalid ${se} attribute value`);\n        const w = parseInt(u),\n          {\n            blockSize: m\n          } = p[0];\n        m && f(w, m);\n      });\n    }),\n    [c] = M(() => {\n      if (typeof ResizeObserver < \"u\") return new ResizeObserver(l);\n    });\n  J(() => {\n    if (c) return () => {\n      c.disconnect();\n    };\n  }, [c]);\n  const d = D(a => c ? (a.forEach(h => c.observe(h)), () => {\n    a.forEach(h => c.unobserve(h));\n  }) : () => {}, [c]);\n  return A(() => ({\n    getAverageRowHeight: o,\n    getRowHeight: i,\n    setRowHeight: f,\n    observeRowElements: d\n  }), [o, i, f, d]);\n}\nconst Le = M,\n  Me = K;\nlet C = -1;\nfunction $e(e = !1) {\n  if (C === -1 || e) {\n    const t = document.createElement(\"div\"),\n      s = t.style;\n    s.width = \"50px\", s.height = \"50px\", s.overflow = \"scroll\", document.body.appendChild(t), C = t.offsetWidth - t.clientWidth, document.body.removeChild(t);\n  }\n  return C;\n}\nexport { Ee as Grid, Ae as List, $e as getScrollbarSize, ke as useDynamicRowHeight, Re as useGridCallbackRef, Ve as useGridRef, Le as useListCallbackRef, Me as useListRef };","map":{"version":3,"names":["xe","e","t","dir","parentElement","ve","s","r","M","re","q","window","J","ie","endsWith","parseFloat","be","box","defaultHeight","defaultWidth","disabled","element","n","mode","o","style","i","styleHeight","f","styleWidth","l","A","height","width","c","d","a","h","ResizeObserver","p","I","contentRect","u","target","w","m","observe","unobserve","ae","K","Error","current","D","U","Ie","document","createElement","overflow","direction","appendChild","body","scrollLeft","removeChild","Z","containerElement","isRtl","scrollOffset","clientWidth","scrollWidth","L","console","error","Y","Object","keys","length","is","fe","cachedBounds","itemCount","itemSize","get","size","we","align","index","containerScrollOffset","containerSize","RangeError","cause","Math","max","min","P","overscanCount","startIndexVisible","stopIndexVisible","startIndexOverscan","stopIndexOverscan","me","itemProps","Map","set","Oe","ye","parseInt","te","containerStyle","defaultContainerSize","onResize","g","O","G","x","F","V","z","$","S","scrollTop","onScroll","E","b","v","R","addEventListener","removeEventListener","y","scrollTo","getCellBounds","getEstimatedSize","scrollToIndex","de","values","ue","ariaAttributes","Ee","cellComponent","cellProps","children","className","columnCount","columnWidth","gridRef","onCellsRendered","rowCount","rowHeight","tagName","le","k","ne","Q","_","oe","ce","scrollToCell","behavior","H","columnAlign","T","columnIndex","W","rowAlign","B","rowIndex","j","N","ge","left","top","scrollToColumn","scrollToRow","columnStartIndex","columnStopIndex","rowStartIndex","rowStopIndex","he","push","X","role","key","position","right","transform","ee","pe","zIndex","ref","maxHeight","maxWidth","flexGrow","Re","Ve","ze","getAverageRowHeight","se","Ae","listRef","onRowsRendered","rowComponent","rowProps","getRowHeight","Array","from","filter","hasAttribute","setAttribute","observeRowElements","startIndex","stopIndex","overflowY","ke","defaultRowHeight","map","forEach","borderBoxSize","getAttribute","blockSize","disconnect","setRowHeight","Le","Me","C","$e","offsetWidth"],"sources":["C:\\Users\\rayuv\\OneDrive\\Documents\\GitHub\\Reacttv\\node_modules\\react-window\\lib\\utils\\isRtl.ts","C:\\Users\\rayuv\\OneDrive\\Documents\\GitHub\\Reacttv\\node_modules\\react-window\\lib\\core\\useIsRtl.ts","C:\\Users\\rayuv\\OneDrive\\Documents\\GitHub\\Reacttv\\node_modules\\react-window\\lib\\hooks\\useIsomorphicLayoutEffect.ts","C:\\Users\\rayuv\\OneDrive\\Documents\\GitHub\\Reacttv\\node_modules\\react-window\\lib\\utils\\parseNumericStyleValue.ts","C:\\Users\\rayuv\\OneDrive\\Documents\\GitHub\\Reacttv\\node_modules\\react-window\\lib\\hooks\\useResizeObserver.ts","C:\\Users\\rayuv\\OneDrive\\Documents\\GitHub\\Reacttv\\node_modules\\react-window\\lib\\hooks\\useStableCallback.ts","C:\\Users\\rayuv\\OneDrive\\Documents\\GitHub\\Reacttv\\node_modules\\react-window\\lib\\utils\\getRTLOffsetType.ts","C:\\Users\\rayuv\\OneDrive\\Documents\\GitHub\\Reacttv\\node_modules\\react-window\\lib\\utils\\adjustScrollOffsetForRtl.ts","C:\\Users\\rayuv\\OneDrive\\Documents\\GitHub\\Reacttv\\node_modules\\react-window\\lib\\utils\\assert.ts","C:\\Users\\rayuv\\OneDrive\\Documents\\GitHub\\Reacttv\\node_modules\\react-window\\lib\\utils\\shallowCompare.ts","C:\\Users\\rayuv\\OneDrive\\Documents\\GitHub\\Reacttv\\node_modules\\react-window\\lib\\core\\getEstimatedSize.ts","C:\\Users\\rayuv\\OneDrive\\Documents\\GitHub\\Reacttv\\node_modules\\react-window\\lib\\core\\getOffsetForIndex.ts","C:\\Users\\rayuv\\OneDrive\\Documents\\GitHub\\Reacttv\\node_modules\\react-window\\lib\\core\\getStartStopIndices.ts","C:\\Users\\rayuv\\OneDrive\\Documents\\GitHub\\Reacttv\\node_modules\\react-window\\lib\\core\\createCachedBounds.ts","C:\\Users\\rayuv\\OneDrive\\Documents\\GitHub\\Reacttv\\node_modules\\react-window\\lib\\core\\useCachedBounds.ts","C:\\Users\\rayuv\\OneDrive\\Documents\\GitHub\\Reacttv\\node_modules\\react-window\\lib\\core\\useItemSize.ts","C:\\Users\\rayuv\\OneDrive\\Documents\\GitHub\\Reacttv\\node_modules\\react-window\\lib\\core\\useVirtualizer.ts","C:\\Users\\rayuv\\OneDrive\\Documents\\GitHub\\Reacttv\\node_modules\\react-window\\lib\\hooks\\useMemoizedObject.ts","C:\\Users\\rayuv\\OneDrive\\Documents\\GitHub\\Reacttv\\node_modules\\react-window\\lib\\utils\\arePropsEqual.ts","C:\\Users\\rayuv\\OneDrive\\Documents\\GitHub\\Reacttv\\node_modules\\react-window\\lib\\components\\grid\\Grid.tsx","C:\\Users\\rayuv\\OneDrive\\Documents\\GitHub\\Reacttv\\node_modules\\react-window\\lib\\components\\grid\\useGridCallbackRef.ts","C:\\Users\\rayuv\\OneDrive\\Documents\\GitHub\\Reacttv\\node_modules\\react-window\\lib\\components\\grid\\useGridRef.ts","C:\\Users\\rayuv\\OneDrive\\Documents\\GitHub\\Reacttv\\node_modules\\react-window\\lib\\components\\list\\isDynamicRowHeight.ts","C:\\Users\\rayuv\\OneDrive\\Documents\\GitHub\\Reacttv\\node_modules\\react-window\\lib\\components\\list\\List.tsx","C:\\Users\\rayuv\\OneDrive\\Documents\\GitHub\\Reacttv\\node_modules\\react-window\\lib\\components\\list\\useDynamicRowHeight.ts","C:\\Users\\rayuv\\OneDrive\\Documents\\GitHub\\Reacttv\\node_modules\\react-window\\lib\\components\\list\\useListCallbackRef.ts","C:\\Users\\rayuv\\OneDrive\\Documents\\GitHub\\Reacttv\\node_modules\\react-window\\lib\\components\\list\\useListRef.ts","C:\\Users\\rayuv\\OneDrive\\Documents\\GitHub\\Reacttv\\node_modules\\react-window\\lib\\utils\\getScrollbarSize.ts"],"sourcesContent":["export function isRtl(element: HTMLElement) {\n  let currentElement: HTMLElement | null = element;\n  while (currentElement) {\n    if (currentElement.dir) {\n      return currentElement.dir === \"rtl\";\n    }\n\n    currentElement = currentElement.parentElement;\n  }\n\n  return false;\n}\n","import { useLayoutEffect, useState, type HTMLAttributes } from \"react\";\nimport { isRtl } from \"../utils/isRtl\";\n\nexport function useIsRtl(\n  element: HTMLElement | null,\n  dir: HTMLAttributes<HTMLElement>[\"dir\"]\n) {\n  const [value, setValue] = useState(dir === \"rtl\");\n\n  useLayoutEffect(() => {\n    if (element) {\n      if (!dir) {\n        setValue(isRtl(element));\n      }\n    }\n  }, [dir, element]);\n\n  return value;\n}\n","import { useEffect, useLayoutEffect } from \"react\";\n\nexport const useIsomorphicLayoutEffect =\n  typeof window !== \"undefined\" ? useLayoutEffect : useEffect;\n","import type { CSSProperties } from \"react\";\n\nexport function parseNumericStyleValue(\n  value: CSSProperties[\"height\"]\n): number | undefined {\n  if (value !== undefined) {\n    switch (typeof value) {\n      case \"number\": {\n        return value;\n      }\n      case \"string\": {\n        if (value.endsWith(\"px\")) {\n          return parseFloat(value);\n        }\n        break;\n      }\n    }\n  }\n}\n","import { useMemo, useState, type CSSProperties } from \"react\";\nimport { parseNumericStyleValue } from \"../utils/parseNumericStyleValue\";\nimport { useIsomorphicLayoutEffect } from \"./useIsomorphicLayoutEffect\";\n\nexport function useResizeObserver({\n  box,\n  defaultHeight,\n  defaultWidth,\n  disabled: disabledProp,\n  element,\n  mode,\n  style\n}: {\n  box?: ResizeObserverBoxOptions;\n  defaultHeight?: number;\n  defaultWidth?: number;\n  disabled?: boolean;\n  element: HTMLElement | null;\n  mode?: \"only-height\" | \"only-width\";\n  style: CSSProperties | undefined;\n}) {\n  const { styleHeight, styleWidth } = useMemo(\n    () => ({\n      styleHeight: parseNumericStyleValue(style?.height),\n      styleWidth: parseNumericStyleValue(style?.width)\n    }),\n    [style?.height, style?.width]\n  );\n\n  const [state, setState] = useState<{\n    height: number | undefined;\n    width: number | undefined;\n  }>({\n    height: defaultHeight,\n    width: defaultWidth\n  });\n\n  const disabled =\n    disabledProp ||\n    (mode === \"only-height\" && styleHeight !== undefined) ||\n    (mode === \"only-width\" && styleWidth !== undefined) ||\n    (styleHeight !== undefined && styleWidth !== undefined);\n\n  useIsomorphicLayoutEffect(() => {\n    if (element === null || disabled) {\n      return;\n    }\n\n    const resizeObserver = new ResizeObserver((entries) => {\n      for (const entry of entries) {\n        const { contentRect, target } = entry;\n        if (element === target) {\n          setState((prevState) => {\n            if (\n              prevState.height === contentRect.height &&\n              prevState.width === contentRect.width\n            ) {\n              return prevState;\n            }\n\n            return {\n              height: contentRect.height,\n              width: contentRect.width\n            };\n          });\n        }\n      }\n    });\n    resizeObserver.observe(element, { box });\n\n    return () => {\n      resizeObserver?.unobserve(element);\n    };\n  }, [box, disabled, element, styleHeight, styleWidth]);\n\n  return useMemo(\n    () => ({\n      height: styleHeight ?? state.height,\n      width: styleWidth ?? state.width\n    }),\n    [state, styleHeight, styleWidth]\n  );\n}\n","import { useCallback, useRef } from \"react\";\nimport { useIsomorphicLayoutEffect } from \"./useIsomorphicLayoutEffect\";\n\n// Forked from useEventCallback (usehooks-ts)\nexport function useStableCallback<Args, Return>(\n  fn: (args: Args) => Return\n): (args: Args) => Return {\n  const ref = useRef<typeof fn>(() => {\n    throw new Error(\"Cannot call during render.\");\n  });\n\n  useIsomorphicLayoutEffect(() => {\n    ref.current = fn;\n  }, [fn]);\n\n  return useCallback((args: Args) => ref.current?.(args), [ref]) as (\n    args: Args\n  ) => Return;\n}\n","export type RTLOffsetType =\n  | \"negative\"\n  | \"positive-descending\"\n  | \"positive-ascending\";\n\nlet cachedRTLResult: RTLOffsetType | null = null;\n\n// TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n// Chrome does not seem to adhere; its scrollLeft values are positive (measured relative to the left).\n// Safari's elastic bounce makes detecting this even more complicated wrt potential false positives.\n// The safest way to check this is to intentionally set a negative offset,\n// and then verify that the subsequent \"scroll\" event matches the negative offset.\n// If it does not match, then we can assume a non-standard RTL scroll implementation.\nexport function getRTLOffsetType(recalculate: boolean = false): RTLOffsetType {\n  if (cachedRTLResult === null || recalculate) {\n    const outerDiv = document.createElement(\"div\");\n    const outerStyle = outerDiv.style;\n    outerStyle.width = \"50px\";\n    outerStyle.height = \"50px\";\n    outerStyle.overflow = \"scroll\";\n    outerStyle.direction = \"rtl\";\n\n    const innerDiv = document.createElement(\"div\");\n    const innerStyle = innerDiv.style;\n    innerStyle.width = \"100px\";\n    innerStyle.height = \"100px\";\n\n    outerDiv.appendChild(innerDiv);\n\n    document.body.appendChild(outerDiv);\n\n    if (outerDiv.scrollLeft > 0) {\n      cachedRTLResult = \"positive-descending\";\n    } else {\n      outerDiv.scrollLeft = 1;\n      if (outerDiv.scrollLeft === 0) {\n        cachedRTLResult = \"negative\";\n      } else {\n        cachedRTLResult = \"positive-ascending\";\n      }\n    }\n\n    document.body.removeChild(outerDiv);\n\n    return cachedRTLResult;\n  }\n\n  return cachedRTLResult;\n}\n","import type { Direction } from \"../core/types\";\nimport { getRTLOffsetType } from \"./getRTLOffsetType\";\n\nexport function adjustScrollOffsetForRtl({\n  containerElement,\n  direction,\n  isRtl,\n  scrollOffset\n}: {\n  containerElement: HTMLElement | null;\n  direction: Direction;\n  isRtl: boolean;\n  scrollOffset: number;\n}) {\n  // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n  // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n  // So we need to determine which browser behavior we're dealing with, and mimic it.\n  if (direction === \"horizontal\") {\n    if (isRtl) {\n      switch (getRTLOffsetType()) {\n        case \"negative\": {\n          return -scrollOffset;\n        }\n        case \"positive-descending\": {\n          if (containerElement) {\n            const { clientWidth, scrollLeft, scrollWidth } = containerElement;\n            return scrollWidth - clientWidth - scrollLeft;\n          }\n          break;\n        }\n      }\n    }\n  }\n  return scrollOffset;\n}\n","export function assert(\n  expectedCondition: unknown,\n  message: string = \"Assertion error\"\n): asserts expectedCondition {\n  if (!expectedCondition) {\n    console.error(message);\n\n    throw Error(message);\n  }\n}\n","import { assert } from \"./assert\";\n\nexport function shallowCompare<Type extends object>(\n  a: Type | undefined,\n  b: Type | undefined\n) {\n  if (a === b) {\n    return true;\n  }\n\n  if (!!a !== !!b) {\n    return false;\n  }\n\n  assert(a !== undefined);\n  assert(b !== undefined);\n\n  if (Object.keys(a).length !== Object.keys(b).length) {\n    return false;\n  }\n\n  for (const key in a) {\n    if (!Object.is(b[key], a[key])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","import type { CachedBounds, SizeFunction } from \"./types\";\nimport { assert } from \"../utils/assert\";\n\nexport function getEstimatedSize<Props extends object>({\n  cachedBounds,\n  itemCount,\n  itemSize\n}: {\n  cachedBounds: CachedBounds;\n  itemCount: number;\n  itemSize: number | SizeFunction<Props>;\n}) {\n  if (itemCount === 0) {\n    return 0;\n  } else if (typeof itemSize === \"number\") {\n    return itemCount * itemSize;\n  } else {\n    const bounds = cachedBounds.get(\n      cachedBounds.size === 0 ? 0 : cachedBounds.size - 1\n    );\n    assert(bounds !== undefined, \"Unexpected bounds cache miss\");\n\n    const averageItemSize =\n      (bounds.scrollOffset + bounds.size) / cachedBounds.size;\n\n    return itemCount * averageItemSize;\n  }\n}\n","import type { Align } from \"../types\";\nimport { getEstimatedSize } from \"./getEstimatedSize\";\nimport type { CachedBounds, SizeFunction } from \"./types\";\n\nexport function getOffsetForIndex<Props extends object>({\n  align,\n  cachedBounds,\n  index,\n  itemCount,\n  itemSize,\n  containerScrollOffset,\n  containerSize\n}: {\n  align: Align;\n  cachedBounds: CachedBounds;\n  index: number;\n  itemCount: number;\n  itemSize: number | SizeFunction<Props>;\n  containerScrollOffset: number;\n  containerSize: number;\n}) {\n  if (index < 0 || index >= itemCount) {\n    throw RangeError(`Invalid index specified: ${index}`, {\n      cause: `Index ${index} is not within the range of 0 - ${itemCount - 1}`\n    });\n  }\n\n  const estimatedTotalSize = getEstimatedSize({\n    cachedBounds,\n    itemCount,\n    itemSize\n  });\n\n  const bounds = cachedBounds.get(index);\n  const maxOffset = Math.max(\n    0,\n    Math.min(estimatedTotalSize - containerSize, bounds.scrollOffset)\n  );\n  const minOffset = Math.max(\n    0,\n    bounds.scrollOffset - containerSize + bounds.size\n  );\n\n  if (align === \"smart\") {\n    if (\n      containerScrollOffset >= minOffset &&\n      containerScrollOffset <= maxOffset\n    ) {\n      align = \"auto\";\n    } else {\n      align = \"center\";\n    }\n  }\n\n  switch (align) {\n    case \"start\": {\n      return maxOffset;\n    }\n    case \"end\": {\n      return minOffset;\n    }\n    case \"center\": {\n      if (bounds.scrollOffset <= containerSize / 2) {\n        // Too near the beginning to center-align\n        return 0;\n      } else if (\n        bounds.scrollOffset + bounds.size / 2 >=\n        estimatedTotalSize - containerSize / 2\n      ) {\n        // Too near the end to center-align\n        return estimatedTotalSize - containerSize;\n      } else {\n        return bounds.scrollOffset + bounds.size / 2 - containerSize / 2;\n      }\n    }\n    case \"auto\":\n    default: {\n      if (\n        containerScrollOffset >= minOffset &&\n        containerScrollOffset <= maxOffset\n      ) {\n        return containerScrollOffset;\n      } else if (containerScrollOffset < minOffset) {\n        return minOffset;\n      } else {\n        return maxOffset;\n      }\n    }\n  }\n}\n","import type { CachedBounds } from \"./types\";\n\nexport function getStartStopIndices({\n  cachedBounds,\n  containerScrollOffset,\n  containerSize,\n  itemCount,\n  overscanCount\n}: {\n  cachedBounds: CachedBounds;\n  containerScrollOffset: number;\n  containerSize: number;\n  itemCount: number;\n  overscanCount: number;\n}): {\n  startIndexVisible: number;\n  stopIndexVisible: number;\n  startIndexOverscan: number;\n  stopIndexOverscan: number;\n} {\n  const maxIndex = itemCount - 1;\n\n  let startIndexVisible = 0;\n  let stopIndexVisible = -1;\n  let startIndexOverscan = 0;\n  let stopIndexOverscan = -1;\n  let currentIndex = 0;\n\n  while (currentIndex < maxIndex) {\n    const bounds = cachedBounds.get(currentIndex);\n\n    if (bounds.scrollOffset + bounds.size > containerScrollOffset) {\n      break;\n    }\n\n    currentIndex++;\n  }\n\n  startIndexVisible = currentIndex;\n  startIndexOverscan = Math.max(0, startIndexVisible - overscanCount);\n\n  while (currentIndex < maxIndex) {\n    const bounds = cachedBounds.get(currentIndex);\n\n    if (\n      bounds.scrollOffset + bounds.size >=\n      containerScrollOffset + containerSize\n    ) {\n      break;\n    }\n\n    currentIndex++;\n  }\n\n  stopIndexVisible = Math.min(maxIndex, currentIndex);\n  stopIndexOverscan = Math.min(itemCount - 1, stopIndexVisible + overscanCount);\n\n  if (startIndexVisible < 0) {\n    startIndexVisible = 0;\n    stopIndexVisible = -1;\n    startIndexOverscan = 0;\n    stopIndexOverscan = -1;\n  }\n\n  return {\n    startIndexVisible,\n    stopIndexVisible,\n    startIndexOverscan,\n    stopIndexOverscan\n  };\n}\n","import { assert } from \"../utils/assert\";\nimport type { Bounds, CachedBounds, SizeFunction } from \"./types\";\n\nexport function createCachedBounds<Props extends object>({\n  itemCount,\n  itemProps,\n  itemSize\n}: {\n  itemCount: number;\n  itemProps: Props;\n  itemSize: number | SizeFunction<Props>;\n}): CachedBounds {\n  const cache = new Map<number, Bounds>();\n\n  return {\n    get(index: number) {\n      assert(index < itemCount, `Invalid index ${index}`);\n\n      while (cache.size - 1 < index) {\n        const currentIndex = cache.size;\n\n        let size: number;\n        switch (typeof itemSize) {\n          case \"function\": {\n            size = itemSize(currentIndex, itemProps);\n            break;\n          }\n          case \"number\": {\n            size = itemSize;\n            break;\n          }\n        }\n\n        if (currentIndex === 0) {\n          cache.set(currentIndex, {\n            size,\n            scrollOffset: 0\n          });\n        } else {\n          const previousRowBounds = cache.get(currentIndex - 1);\n          assert(\n            previousRowBounds !== undefined,\n            `Unexpected bounds cache miss for index ${index}`\n          );\n\n          cache.set(currentIndex, {\n            scrollOffset:\n              previousRowBounds.scrollOffset + previousRowBounds.size,\n            size\n          });\n        }\n      }\n\n      const bounds = cache.get(index);\n      assert(\n        bounds !== undefined,\n        `Unexpected bounds cache miss for index ${index}`\n      );\n\n      return bounds;\n    },\n    set(index: number, bounds: Bounds) {\n      cache.set(index, bounds);\n    },\n    get size() {\n      return cache.size;\n    }\n  };\n}\n","import { useMemo } from \"react\";\nimport { createCachedBounds } from \"./createCachedBounds\";\nimport type { CachedBounds, SizeFunction } from \"./types\";\n\nexport function useCachedBounds<Props extends object>({\n  itemCount,\n  itemProps,\n  itemSize\n}: {\n  itemCount: number;\n  itemProps: Props;\n  itemSize: number | SizeFunction<Props>;\n}): CachedBounds {\n  return useMemo(\n    () =>\n      createCachedBounds({\n        itemCount,\n        itemProps,\n        itemSize\n      }),\n    [itemCount, itemProps, itemSize]\n  );\n}\n","import { assert } from \"../utils/assert\";\nimport type { SizeFunction } from \"./types\";\n\nexport function useItemSize<Props extends object>({\n  containerSize,\n  itemSize: itemSizeProp\n}: {\n  containerSize: number;\n  itemSize: number | string | SizeFunction<Props>;\n}) {\n  let itemSize: number | SizeFunction<Props>;\n  switch (typeof itemSizeProp) {\n    case \"string\": {\n      assert(\n        itemSizeProp.endsWith(\"%\"),\n        `Invalid item size: \"${itemSizeProp}\"; string values must be percentages (e.g. \"100%\")`\n      );\n      assert(\n        containerSize !== undefined,\n        \"Container size must be defined if a percentage item size is specified\"\n      );\n\n      itemSize = (containerSize * parseInt(itemSizeProp)) / 100;\n      break;\n    }\n    default: {\n      itemSize = itemSizeProp;\n      break;\n    }\n  }\n\n  return itemSize;\n}\n","import {\n  useCallback,\n  useLayoutEffect,\n  useRef,\n  useState,\n  type CSSProperties\n} from \"react\";\nimport { useIsomorphicLayoutEffect } from \"../hooks/useIsomorphicLayoutEffect\";\nimport { useResizeObserver } from \"../hooks/useResizeObserver\";\nimport { useStableCallback } from \"../hooks/useStableCallback\";\nimport type { Align } from \"../types\";\nimport { adjustScrollOffsetForRtl } from \"../utils/adjustScrollOffsetForRtl\";\nimport { shallowCompare } from \"../utils/shallowCompare\";\nimport { getEstimatedSize as getEstimatedSizeUtil } from \"./getEstimatedSize\";\nimport { getOffsetForIndex } from \"./getOffsetForIndex\";\nimport { getStartStopIndices as getStartStopIndicesUtil } from \"./getStartStopIndices\";\nimport type { Direction, SizeFunction } from \"./types\";\nimport { useCachedBounds } from \"./useCachedBounds\";\nimport { useItemSize } from \"./useItemSize\";\n\nexport function useVirtualizer<Props extends object>({\n  containerElement,\n  containerStyle,\n  defaultContainerSize = 0,\n  direction,\n  isRtl = false,\n  itemCount,\n  itemProps,\n  itemSize: itemSizeProp,\n  onResize,\n  overscanCount\n}: {\n  containerElement: HTMLElement | null;\n  containerStyle?: CSSProperties;\n  defaultContainerSize?: number;\n  direction: Direction;\n  isRtl?: boolean;\n  itemCount: number;\n  itemProps: Props;\n  itemSize: number | string | SizeFunction<Props>;\n  onResize:\n    | ((\n        size: { height: number; width: number },\n        prevSize: { height: number; width: number }\n      ) => void)\n    | undefined;\n  overscanCount: number;\n}) {\n  const { height = defaultContainerSize, width = defaultContainerSize } =\n    useResizeObserver({\n      defaultHeight:\n        direction === \"vertical\" ? defaultContainerSize : undefined,\n      defaultWidth:\n        direction === \"horizontal\" ? defaultContainerSize : undefined,\n      element: containerElement,\n      mode: direction === \"vertical\" ? \"only-height\" : \"only-width\",\n      style: containerStyle\n    });\n\n  const prevSizeRef = useRef<{ height: number; width: number }>({\n    height: 0,\n    width: 0\n  });\n\n  const containerSize = direction === \"vertical\" ? height : width;\n\n  const itemSize = useItemSize({ containerSize, itemSize: itemSizeProp });\n\n  useLayoutEffect(() => {\n    if (typeof onResize === \"function\") {\n      const prevSize = prevSizeRef.current;\n\n      if (prevSize.height !== height || prevSize.width !== width) {\n        onResize({ height, width }, { ...prevSize });\n\n        prevSize.height = height;\n        prevSize.width = width;\n      }\n    }\n  }, [height, onResize, width]);\n\n  const cachedBounds = useCachedBounds({\n    itemCount,\n    itemProps,\n    itemSize\n  });\n\n  const getCellBounds = useCallback(\n    (index: number) => cachedBounds.get(index),\n    [cachedBounds]\n  );\n\n  const [indices, setIndices] = useState<{\n    startIndexVisible: number;\n    stopIndexVisible: number;\n    startIndexOverscan: number;\n    stopIndexOverscan: number;\n  }>(() =>\n    getStartStopIndicesUtil({\n      cachedBounds,\n      // TODO Potentially support a defaultScrollOffset prop?\n      containerScrollOffset: 0,\n      containerSize,\n      itemCount,\n      overscanCount\n    })\n  );\n\n  // Guard against temporarily invalid indices that may occur when item count decreases\n  // Cached bounds object will be re-created and a second render will restore things\n  const {\n    startIndexVisible,\n    startIndexOverscan,\n    stopIndexVisible,\n    stopIndexOverscan\n  } = {\n    startIndexVisible: Math.min(itemCount - 1, indices.startIndexVisible),\n    startIndexOverscan: Math.min(itemCount - 1, indices.startIndexOverscan),\n    stopIndexVisible: Math.min(itemCount - 1, indices.stopIndexVisible),\n    stopIndexOverscan: Math.min(itemCount - 1, indices.stopIndexOverscan)\n  };\n\n  const getEstimatedSize = useCallback(\n    () =>\n      getEstimatedSizeUtil({\n        cachedBounds,\n        itemCount,\n        itemSize\n      }),\n    [cachedBounds, itemCount, itemSize]\n  );\n\n  const getStartStopIndices = useCallback(\n    (scrollOffset: number) => {\n      const containerScrollOffset = adjustScrollOffsetForRtl({\n        containerElement,\n        direction,\n        isRtl,\n        scrollOffset\n      });\n\n      return getStartStopIndicesUtil({\n        cachedBounds,\n        containerScrollOffset,\n        containerSize,\n        itemCount,\n        overscanCount\n      });\n    },\n    [\n      cachedBounds,\n      containerElement,\n      containerSize,\n      direction,\n      isRtl,\n      itemCount,\n      overscanCount\n    ]\n  );\n\n  useIsomorphicLayoutEffect(() => {\n    const scrollOffset =\n      (direction === \"vertical\"\n        ? containerElement?.scrollTop\n        : containerElement?.scrollLeft) ?? 0;\n\n    setIndices(getStartStopIndices(scrollOffset));\n  }, [containerElement, direction, getStartStopIndices]);\n\n  useIsomorphicLayoutEffect(() => {\n    if (!containerElement) {\n      return;\n    }\n\n    const onScroll = () => {\n      setIndices((prev) => {\n        const { scrollLeft, scrollTop } = containerElement;\n\n        const scrollOffset = adjustScrollOffsetForRtl({\n          containerElement,\n          direction,\n          isRtl,\n          scrollOffset: direction === \"vertical\" ? scrollTop : scrollLeft\n        });\n\n        const next = getStartStopIndicesUtil({\n          cachedBounds,\n          containerScrollOffset: scrollOffset,\n          containerSize,\n          itemCount,\n          overscanCount\n        });\n\n        if (shallowCompare(next, prev)) {\n          return prev;\n        }\n\n        return next;\n      });\n    };\n\n    containerElement.addEventListener(\"scroll\", onScroll);\n\n    return () => {\n      containerElement.removeEventListener(\"scroll\", onScroll);\n    };\n  }, [\n    cachedBounds,\n    containerElement,\n    containerSize,\n    direction,\n    itemCount,\n    overscanCount\n  ]);\n\n  const scrollToIndex = useStableCallback(\n    ({\n      align = \"auto\",\n      containerScrollOffset,\n      index\n    }: {\n      align?: Align;\n      containerScrollOffset: number;\n      index: number;\n    }) => {\n      let scrollOffset = getOffsetForIndex({\n        align,\n        cachedBounds,\n        containerScrollOffset,\n        containerSize,\n        index,\n        itemCount,\n        itemSize\n      });\n\n      if (containerElement) {\n        scrollOffset = adjustScrollOffsetForRtl({\n          containerElement,\n          direction,\n          isRtl,\n          scrollOffset\n        });\n\n        if (typeof containerElement.scrollTo !== \"function\") {\n          // Special case for environments like jsdom that don't implement scrollTo\n          const next = getStartStopIndices(scrollOffset);\n          if (!shallowCompare(indices, next)) {\n            setIndices(next);\n          }\n        }\n\n        return scrollOffset;\n      }\n    }\n  );\n\n  return {\n    getCellBounds,\n    getEstimatedSize,\n    scrollToIndex,\n    startIndexOverscan,\n    startIndexVisible,\n    stopIndexOverscan,\n    stopIndexVisible\n  };\n}\n","import { useMemo } from \"react\";\n\nexport function useMemoizedObject<Type extends object>(\n  unstableObject: Type\n): Type {\n  return useMemo(() => {\n    return unstableObject;\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, Object.values(unstableObject));\n}\n","import type { CSSProperties } from \"react\";\nimport { shallowCompare } from \"./shallowCompare\";\n\n// Custom comparison function for React.memo()\n// It knows to compare individual style props and ignore the wrapper object.\n// See https://react.dev/reference/react/memo#memo\nexport function arePropsEqual(\n  prevProps: { ariaAttributes: object; style: CSSProperties },\n  nextProps: { ariaAttributes: object; style: CSSProperties }\n): boolean {\n  const {\n    ariaAttributes: prevAriaAttributes,\n    style: prevStyle,\n    ...prevRest\n  } = prevProps;\n  const {\n    ariaAttributes: nextAriaAttributes,\n    style: nextStyle,\n    ...nextRest\n  } = nextProps;\n\n  return (\n    shallowCompare(prevAriaAttributes, nextAriaAttributes) &&\n    shallowCompare(prevStyle, nextStyle) &&\n    shallowCompare(prevRest, nextRest)\n  );\n}\n","\"use client\";\n\nimport {\n  createElement,\n  memo,\n  useEffect,\n  useImperativeHandle,\n  useMemo,\n  useState,\n  type ReactElement,\n  type ReactNode\n} from \"react\";\nimport { useIsRtl } from \"../../core/useIsRtl\";\nimport { useVirtualizer } from \"../../core/useVirtualizer\";\nimport { useMemoizedObject } from \"../../hooks/useMemoizedObject\";\nimport type { Align, TagNames } from \"../../types\";\nimport { arePropsEqual } from \"../../utils/arePropsEqual\";\nimport type { GridProps } from \"./types\";\n\n/**\n * Renders data with many rows and columns.\n *\n *  Unlike `List` rows, `Grid` cell sizes must be known ahead of time.\n * Either static sizes or something that can be derived (from the data in `CellProps`) without rendering.\n */\nexport function Grid<\n  CellProps extends object,\n  TagName extends TagNames = \"div\"\n>({\n  cellComponent: CellComponentProp,\n  cellProps: cellPropsUnstable,\n  children,\n  className,\n  columnCount,\n  columnWidth,\n  defaultHeight = 0,\n  defaultWidth = 0,\n  dir,\n  gridRef,\n  onCellsRendered,\n  onResize,\n  overscanCount = 3,\n  rowCount,\n  rowHeight,\n  style,\n  tagName = \"div\" as TagName,\n  ...rest\n}: GridProps<CellProps, TagName>): ReactElement {\n  const cellProps = useMemoizedObject(cellPropsUnstable);\n  const CellComponent = useMemo(\n    () => memo(CellComponentProp, arePropsEqual),\n    [CellComponentProp]\n  );\n\n  const [element, setElement] = useState<HTMLDivElement | null>(null);\n\n  const isRtl = useIsRtl(element, dir);\n\n  const {\n    getCellBounds: getColumnBounds,\n    getEstimatedSize: getEstimatedWidth,\n    startIndexOverscan: columnStartIndexOverscan,\n    startIndexVisible: columnStartIndexVisible,\n    scrollToIndex: scrollToColumnIndex,\n    stopIndexOverscan: columnStopIndexOverscan,\n    stopIndexVisible: columnStopIndexVisible\n  } = useVirtualizer({\n    containerElement: element,\n    containerStyle: style,\n    defaultContainerSize: defaultWidth,\n    direction: \"horizontal\",\n    isRtl,\n    itemCount: columnCount,\n    itemProps: cellProps,\n    itemSize: columnWidth,\n    onResize,\n    overscanCount\n  });\n\n  const {\n    getCellBounds: getRowBounds,\n    getEstimatedSize: getEstimatedHeight,\n    startIndexOverscan: rowStartIndexOverscan,\n    startIndexVisible: rowStartIndexVisible,\n    scrollToIndex: scrollToRowIndex,\n    stopIndexOverscan: rowStopIndexOverscan,\n    stopIndexVisible: rowStopIndexVisible\n  } = useVirtualizer({\n    containerElement: element,\n    containerStyle: style,\n    defaultContainerSize: defaultHeight,\n    direction: \"vertical\",\n    itemCount: rowCount,\n    itemProps: cellProps,\n    itemSize: rowHeight,\n    onResize,\n    overscanCount\n  });\n\n  useImperativeHandle(\n    gridRef,\n    () => ({\n      get element() {\n        return element;\n      },\n\n      scrollToCell({\n        behavior = \"auto\",\n        columnAlign = \"auto\",\n        columnIndex,\n        rowAlign = \"auto\",\n        rowIndex\n      }: {\n        behavior?: ScrollBehavior;\n        columnAlign?: Align;\n        columnIndex: number;\n        rowAlign?: Align;\n        rowIndex: number;\n      }) {\n        const left = scrollToColumnIndex({\n          align: columnAlign,\n          containerScrollOffset: element?.scrollLeft ?? 0,\n          index: columnIndex\n        });\n        const top = scrollToRowIndex({\n          align: rowAlign,\n          containerScrollOffset: element?.scrollTop ?? 0,\n          index: rowIndex\n        });\n\n        if (typeof element?.scrollTo === \"function\") {\n          element.scrollTo({\n            behavior,\n            left,\n            top\n          });\n        }\n      },\n\n      scrollToColumn({\n        align = \"auto\",\n        behavior = \"auto\",\n        index\n      }: {\n        align?: Align;\n        behavior?: ScrollBehavior;\n        index: number;\n      }) {\n        const left = scrollToColumnIndex({\n          align,\n          containerScrollOffset: element?.scrollLeft ?? 0,\n          index\n        });\n\n        if (typeof element?.scrollTo === \"function\") {\n          element.scrollTo({\n            behavior,\n            left\n          });\n        }\n      },\n\n      scrollToRow({\n        align = \"auto\",\n        behavior = \"auto\",\n        index\n      }: {\n        align?: Align;\n        behavior?: ScrollBehavior;\n        index: number;\n      }) {\n        const top = scrollToRowIndex({\n          align,\n          containerScrollOffset: element?.scrollTop ?? 0,\n          index\n        });\n\n        if (typeof element?.scrollTo === \"function\") {\n          element.scrollTo({\n            behavior,\n            top\n          });\n        }\n      }\n    }),\n    [element, scrollToColumnIndex, scrollToRowIndex]\n  );\n\n  useEffect(() => {\n    if (\n      columnStartIndexOverscan >= 0 &&\n      columnStopIndexOverscan >= 0 &&\n      rowStartIndexOverscan >= 0 &&\n      rowStopIndexOverscan >= 0 &&\n      onCellsRendered\n    ) {\n      onCellsRendered(\n        {\n          columnStartIndex: columnStartIndexVisible,\n          columnStopIndex: columnStopIndexVisible,\n          rowStartIndex: rowStartIndexVisible,\n          rowStopIndex: rowStopIndexVisible\n        },\n        {\n          columnStartIndex: columnStartIndexOverscan,\n          columnStopIndex: columnStopIndexOverscan,\n          rowStartIndex: rowStartIndexOverscan,\n          rowStopIndex: rowStopIndexOverscan\n        }\n      );\n    }\n  }, [\n    onCellsRendered,\n    columnStartIndexOverscan,\n    columnStartIndexVisible,\n    columnStopIndexOverscan,\n    columnStopIndexVisible,\n    rowStartIndexOverscan,\n    rowStartIndexVisible,\n    rowStopIndexOverscan,\n    rowStopIndexVisible\n  ]);\n\n  const cells = useMemo(() => {\n    const children: ReactNode[] = [];\n    if (columnCount > 0 && rowCount > 0) {\n      for (\n        let rowIndex = rowStartIndexOverscan;\n        rowIndex <= rowStopIndexOverscan;\n        rowIndex++\n      ) {\n        const rowBounds = getRowBounds(rowIndex);\n\n        const columns: ReactNode[] = [];\n\n        for (\n          let columnIndex = columnStartIndexOverscan;\n          columnIndex <= columnStopIndexOverscan;\n          columnIndex++\n        ) {\n          const columnBounds = getColumnBounds(columnIndex);\n\n          columns.push(\n            <CellComponent\n              {...(cellProps as CellProps)}\n              ariaAttributes={{\n                \"aria-colindex\": columnIndex + 1,\n                role: \"gridcell\"\n              }}\n              columnIndex={columnIndex}\n              key={columnIndex}\n              rowIndex={rowIndex}\n              style={{\n                position: \"absolute\",\n                left: isRtl ? undefined : 0,\n                right: isRtl ? 0 : undefined,\n                transform: `translate(${isRtl ? -columnBounds.scrollOffset : columnBounds.scrollOffset}px, ${rowBounds.scrollOffset}px)`,\n                height: rowBounds.size,\n                width: columnBounds.size\n              }}\n            />\n          );\n        }\n\n        children.push(\n          <div key={rowIndex} role=\"row\" aria-rowindex={rowIndex + 1}>\n            {columns}\n          </div>\n        );\n      }\n    }\n    return children;\n  }, [\n    CellComponent,\n    cellProps,\n    columnCount,\n    columnStartIndexOverscan,\n    columnStopIndexOverscan,\n    getColumnBounds,\n    getRowBounds,\n    isRtl,\n    rowCount,\n    rowStartIndexOverscan,\n    rowStopIndexOverscan\n  ]);\n\n  const sizingElement = (\n    <div\n      aria-hidden\n      style={{\n        height: getEstimatedHeight(),\n        width: getEstimatedWidth(),\n        zIndex: -1\n      }}\n    ></div>\n  );\n\n  return createElement(\n    tagName,\n    {\n      \"aria-colcount\": columnCount,\n      \"aria-rowcount\": rowCount,\n      role: \"grid\",\n      ...rest,\n      className,\n      dir,\n      ref: setElement,\n      style: {\n        position: \"relative\",\n        maxHeight: \"100%\",\n        maxWidth: \"100%\",\n        flexGrow: 1,\n        overflow: \"auto\",\n        ...style\n      }\n    },\n    cells,\n    children,\n    sizingElement\n  );\n}\n","import { useState } from \"react\";\nimport type { GridImperativeAPI } from \"./types\";\n\n/**\n * Convenience hook to return a properly typed ref callback for the Grid component.\n *\n * Use this hook when you need to share the ref with another component or hook.\n */\nexport const useGridCallbackRef =\n  useState as typeof useState<GridImperativeAPI | null>;\n","import { useRef } from \"react\";\nimport type { GridImperativeAPI } from \"./types\";\n\n/**\n * Convenience hook to return a properly typed ref for the Grid component.\n */\nexport const useGridRef = useRef as typeof useRef<GridImperativeAPI>;\n","import type { DynamicRowHeight } from \"./types\";\n\nexport function isDynamicRowHeight(value: unknown): value is DynamicRowHeight {\n  return (\n    value != null &&\n    typeof value === \"object\" &&\n    \"getAverageRowHeight\" in value &&\n    typeof value.getAverageRowHeight === \"function\"\n  );\n}\n","\"use client\";\n\nimport {\n  createElement,\n  memo,\n  useEffect,\n  useImperativeHandle,\n  useMemo,\n  useState,\n  type ReactElement,\n  type ReactNode\n} from \"react\";\nimport { useVirtualizer } from \"../../core/useVirtualizer\";\nimport { useIsomorphicLayoutEffect } from \"../../hooks/useIsomorphicLayoutEffect\";\nimport { useMemoizedObject } from \"../../hooks/useMemoizedObject\";\nimport type { Align, TagNames } from \"../../types\";\nimport { arePropsEqual } from \"../../utils/arePropsEqual\";\nimport { isDynamicRowHeight as isDynamicRowHeightUtil } from \"./isDynamicRowHeight\";\nimport type { ListProps } from \"./types\";\n\nexport const DATA_ATTRIBUTE_LIST_INDEX = \"data-react-window-index\";\n\n/**\n * Renders data with many rows.\n */\nexport function List<\n  RowProps extends object,\n  TagName extends TagNames = \"div\"\n>({\n  children,\n  className,\n  defaultHeight = 0,\n  listRef,\n  onResize,\n  onRowsRendered,\n  overscanCount = 3,\n  rowComponent: RowComponentProp,\n  rowCount,\n  rowHeight: rowHeightProp,\n  rowProps: rowPropsUnstable,\n  tagName = \"div\" as TagName,\n  style,\n  ...rest\n}: ListProps<RowProps, TagName>): ReactElement {\n  const rowProps = useMemoizedObject(rowPropsUnstable);\n  const RowComponent = useMemo(\n    () => memo(RowComponentProp, arePropsEqual),\n    [RowComponentProp]\n  );\n\n  const [element, setElement] = useState<HTMLDivElement | null>(null);\n\n  const isDynamicRowHeight = isDynamicRowHeightUtil(rowHeightProp);\n\n  const rowHeight = useMemo(() => {\n    if (isDynamicRowHeight) {\n      return (index: number) => {\n        return (\n          rowHeightProp.getRowHeight(index) ??\n          rowHeightProp.getAverageRowHeight()\n        );\n      };\n    }\n\n    return rowHeightProp;\n  }, [isDynamicRowHeight, rowHeightProp]);\n\n  const {\n    getCellBounds,\n    getEstimatedSize,\n    scrollToIndex,\n    startIndexOverscan,\n    startIndexVisible,\n    stopIndexOverscan,\n    stopIndexVisible\n  } = useVirtualizer({\n    containerElement: element,\n    containerStyle: style,\n    defaultContainerSize: defaultHeight,\n    direction: \"vertical\",\n    itemCount: rowCount,\n    itemProps: rowProps,\n    itemSize: rowHeight,\n    onResize,\n    overscanCount\n  });\n\n  useImperativeHandle(\n    listRef,\n    () => ({\n      get element() {\n        return element;\n      },\n\n      scrollToRow({\n        align = \"auto\",\n        behavior = \"auto\",\n        index\n      }: {\n        align?: Align;\n        behavior?: ScrollBehavior;\n        index: number;\n      }) {\n        const top = scrollToIndex({\n          align,\n          containerScrollOffset: element?.scrollTop ?? 0,\n          index\n        });\n\n        if (typeof element?.scrollTo === \"function\") {\n          element.scrollTo({\n            behavior,\n            top\n          });\n        }\n      }\n    }),\n    [element, scrollToIndex]\n  );\n\n  useIsomorphicLayoutEffect(() => {\n    if (!element) {\n      return;\n    }\n\n    const rows = Array.from(element.children).filter((item, index) => {\n      if (item.hasAttribute(\"aria-hidden\")) {\n        // Ignore sizing element\n        return false;\n      }\n\n      const attribute = `${startIndexOverscan + index}`;\n      item.setAttribute(DATA_ATTRIBUTE_LIST_INDEX, attribute);\n\n      return true;\n    });\n\n    if (isDynamicRowHeight) {\n      return rowHeightProp.observeRowElements(rows);\n    }\n  }, [\n    element,\n    isDynamicRowHeight,\n    rowHeightProp,\n    startIndexOverscan,\n    stopIndexOverscan\n  ]);\n\n  useEffect(() => {\n    if (startIndexOverscan >= 0 && stopIndexOverscan >= 0 && onRowsRendered) {\n      onRowsRendered(\n        {\n          startIndex: startIndexVisible,\n          stopIndex: stopIndexVisible\n        },\n        {\n          startIndex: startIndexOverscan,\n          stopIndex: stopIndexOverscan\n        }\n      );\n    }\n  }, [\n    onRowsRendered,\n    startIndexOverscan,\n    startIndexVisible,\n    stopIndexOverscan,\n    stopIndexVisible\n  ]);\n\n  const rows = useMemo(() => {\n    const children: ReactNode[] = [];\n    if (rowCount > 0) {\n      for (\n        let index = startIndexOverscan;\n        index <= stopIndexOverscan;\n        index++\n      ) {\n        const bounds = getCellBounds(index);\n\n        children.push(\n          <RowComponent\n            {...(rowProps as RowProps)}\n            ariaAttributes={{\n              \"aria-posinset\": index + 1,\n              \"aria-setsize\": rowCount,\n              role: \"listitem\"\n            }}\n            key={index}\n            index={index}\n            style={{\n              position: \"absolute\",\n              left: 0,\n              transform: `translateY(${bounds.scrollOffset}px)`,\n              // In case of dynamic row heights, don't specify a height style\n              // otherwise a default/estimated height would mask the actual height\n              height: isDynamicRowHeight ? undefined : bounds.size,\n              width: \"100%\"\n            }}\n          />\n        );\n      }\n    }\n    return children;\n  }, [\n    RowComponent,\n    getCellBounds,\n    isDynamicRowHeight,\n    rowCount,\n    rowProps,\n    startIndexOverscan,\n    stopIndexOverscan\n  ]);\n\n  const sizingElement = (\n    <div\n      aria-hidden\n      style={{\n        height: getEstimatedSize(),\n        width: \"100%\",\n        zIndex: -1\n      }}\n    ></div>\n  );\n\n  return createElement(\n    tagName,\n    {\n      role: \"list\",\n      ...rest,\n      className,\n      ref: setElement,\n      style: {\n        position: \"relative\",\n        maxHeight: \"100%\",\n        flexGrow: 1,\n        overflowY: \"auto\",\n        ...style\n      }\n    },\n    rows,\n    children,\n    sizingElement\n  );\n}\n","import { useCallback, useEffect, useMemo, useState } from \"react\";\nimport { useStableCallback } from \"../../hooks/useStableCallback\";\nimport { assert } from \"../../utils/assert\";\nimport { DATA_ATTRIBUTE_LIST_INDEX } from \"./List\";\nimport type { DynamicRowHeight } from \"./types\";\n\nexport function useDynamicRowHeight({\n  defaultRowHeight,\n  key\n}: {\n  defaultRowHeight: number;\n  key?: string | number;\n}) {\n  const [state, setState] = useState<{\n    key: string | number | undefined;\n    map: Map<number, number>;\n  }>({\n    key,\n    map: new Map()\n  });\n\n  if (state.key !== key) {\n    setState({\n      key,\n      map: new Map()\n    });\n  }\n\n  const { map } = state;\n\n  const getAverageRowHeight = useCallback(() => {\n    let totalHeight = 0;\n\n    map.forEach((height) => {\n      totalHeight += height;\n    });\n\n    if (totalHeight === 0) {\n      return defaultRowHeight;\n    }\n\n    return totalHeight / map.size;\n  }, [defaultRowHeight, map]);\n\n  const getRowHeight = useCallback(\n    (index: number) => {\n      const measuredHeight = map.get(index);\n      if (measuredHeight !== undefined) {\n        return measuredHeight;\n      }\n\n      // Temporarily store default height in the cache map to avoid scroll jumps if rowProps change\n      // Else rowProps changes can impact the average height, and cause rows to shift up or down within the list\n      // see github.com/bvaughn/react-window/issues/863\n      map.set(index, defaultRowHeight);\n\n      return defaultRowHeight;\n    },\n    [defaultRowHeight, map]\n  );\n\n  const setRowHeight = useCallback((index: number, size: number) => {\n    setState((prevState) => {\n      if (prevState.map.get(index) === size) {\n        return prevState;\n      }\n\n      const clonedMap = new Map(prevState.map);\n      clonedMap.set(index, size);\n\n      return {\n        ...prevState,\n        map: clonedMap\n      };\n    });\n  }, []);\n\n  const resizeObserverCallback = useStableCallback(\n    (entries: ResizeObserverEntry[]) => {\n      if (entries.length === 0) {\n        return;\n      }\n\n      entries.forEach((entry) => {\n        const { borderBoxSize, target } = entry;\n\n        const attribute = target.getAttribute(DATA_ATTRIBUTE_LIST_INDEX);\n        assert(\n          attribute !== null,\n          `Invalid ${DATA_ATTRIBUTE_LIST_INDEX} attribute value`\n        );\n\n        const index = parseInt(attribute);\n\n        const { blockSize: height } = borderBoxSize[0];\n        if (!height) {\n          // Ignore heights that have not yet been measured (e.g. <img> elements that have not yet loaded)\n          return;\n        }\n\n        setRowHeight(index, height);\n      });\n    }\n  );\n\n  const [resizeObserver] = useState(() => {\n    if (typeof ResizeObserver !== \"undefined\") {\n      return new ResizeObserver(resizeObserverCallback);\n    }\n  });\n\n  useEffect(() => {\n    if (resizeObserver) {\n      return () => {\n        resizeObserver.disconnect();\n      };\n    }\n  }, [resizeObserver]);\n\n  const observeRowElements = useCallback(\n    (elements: Element[] | NodeListOf<Element>) => {\n      if (resizeObserver) {\n        elements.forEach((element) => resizeObserver.observe(element));\n        return () => {\n          elements.forEach((element) => resizeObserver.unobserve(element));\n        };\n      }\n      return () => {};\n    },\n    [resizeObserver]\n  );\n\n  return useMemo<DynamicRowHeight>(\n    () => ({\n      getAverageRowHeight,\n      getRowHeight,\n      setRowHeight,\n      observeRowElements\n    }),\n    [getAverageRowHeight, getRowHeight, setRowHeight, observeRowElements]\n  );\n}\n","import { useState } from \"react\";\nimport type { ListImperativeAPI } from \"./types\";\n\n/**\n * Convenience hook to return a properly typed ref callback for the List component.\n *\n * Use this hook when you need to share the ref with another component or hook.\n */\nexport const useListCallbackRef =\n  useState as typeof useState<ListImperativeAPI | null>;\n","import { useRef } from \"react\";\nimport type { ListImperativeAPI } from \"./types\";\n\n/**\n * Convenience hook to return a properly typed ref for the List component.\n */\nexport const useListRef = useRef as typeof useRef<ListImperativeAPI>;\n","let size: number = -1;\n\nexport function getScrollbarSize(recalculate: boolean = false): number {\n  if (size === -1 || recalculate) {\n    const div = document.createElement(\"div\");\n    const style = div.style;\n    style.width = \"50px\";\n    style.height = \"50px\";\n    style.overflow = \"scroll\";\n\n    document.body.appendChild(div);\n\n    size = div.offsetWidth - div.clientWidth;\n\n    document.body.removeChild(div);\n  }\n\n  return size;\n}\n\nexport function setScrollbarSizeForTests(value: number) {\n  size = value;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}